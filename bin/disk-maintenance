#!/usr/bin/env bash
set -euo pipefail

MODE="${1:-}"

CONFIG_FILE="/etc/disk-maintenance.conf"
STATE_DIR="/var/lib/disk-maintenance"
HISTORY_FILE="$STATE_DIR/history.jsonl"

# Defaults (can be overridden by config)
CLEANUP_THRESHOLD_PCT=85
EMERGENCY_THRESHOLD_PCT=95
EMERGENCY_MIN_FREE_BYTES=$((1024*1024*1024))
JOURNAL_VACUUM_CLEANUP="200M"
JOURNAL_VACUUM_EMERGENCY="50M"
COREDUMP_RETENTION_DAYS=14
SNAP_CLEANUP_ENABLED=1
SNAP_REFRESH_RETAIN=2
DOCKER_PRUNE_ENABLED=1
DOCKER_VOLUME_PRUNE_ENABLED=0
AGENT_CLI="codex"     # none|codex|opencode
AGENT_OUTPUT="json"   # json|plain

# Optional notifications (best-effort)
# Example: EMERGENCY_WEBHOOK_URL="https://example.com/webhook"
EMERGENCY_WEBHOOK_URL=""

# History rotation (best-effort)
HISTORY_MAX_BYTES=$((10*1024*1024))

is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

sudo_cmd() {
  if is_root; then
    "$@"
  else
    command -v sudo >/dev/null 2>&1 || return 1
    sudo "$@"
  fi
}

has_timeout() { command -v timeout >/dev/null 2>&1; }

load_config() {
  if [[ -f "$CONFIG_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$CONFIG_FILE"
  fi
}

root_usage_pct() {
  df -P / | awk 'NR==2{gsub(/%/,"",$5); print $5}'
}

root_free_bytes() {
  df -PB1 / | awk 'NR==2{print $4}'
}

ensure_state_dir() {
  sudo_cmd install -d -m 0755 "$STATE_DIR"
}

rotate_history_if_needed() {
  ensure_state_dir
  [[ -f "$HISTORY_FILE" ]] || return 0

  local size
  size="$(sudo_cmd stat -c %s "$HISTORY_FILE" 2>/dev/null || echo 0)"
  if [[ "$size" -le "$HISTORY_MAX_BYTES" ]]; then
    return 0
  fi

  local ts
  ts="$(date +%Y%m%dT%H%M%S)"
  sudo_cmd mv "$HISTORY_FILE" "$HISTORY_FILE.$ts" || true
  if command -v gzip >/dev/null 2>&1; then
    sudo_cmd gzip -f "$HISTORY_FILE.$ts" || true
  fi
}

json_escape() {
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY'
import json,sys
print(json.dumps(sys.stdin.read()))
PY
  else
    # Minimal fallback; not perfect JSON escaping but prevents obvious breaks.
    sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e ':a;N;$!ba;s/\n/\\n/g'
  fi
}

emit_history_record() {
  rotate_history_if_needed

  local ts usage free df_out
  ts="$(date -Is)"
  usage="$(root_usage_pct)"
  free="$(root_free_bytes)"
  df_out="$(df -hT / | tail -n +1)"

  printf '{"ts":%s,"mode":%s,"root_usage_pct":%s,"root_free_bytes":%s,"df":%s}\n' \
    "$(printf '%s' "$ts" | json_escape)" \
    "$(printf '%s' "$MODE" | json_escape)" \
    "$(printf '%s' "$usage" | json_escape)" \
    "$(printf '%s' "$free" | json_escape)" \
    "$(printf '%s' "$df_out" | json_escape)" \
    | sudo_cmd tee -a "$HISTORY_FILE" >/dev/null
}

report_top() {
  echo "[disk-maintenance] df -hT /"
  df -hT /

  echo
  echo "[disk-maintenance] top dirs (bounded)"
  if has_timeout; then
    sudo_cmd timeout 30s du -xh --max-depth=2 /var/cache /var/log /var/lib/docker 2>/dev/null | sort -h | tail -n 40 || true
  else
    sudo_cmd du -xh --max-depth=2 /var/cache /var/log /var/lib/docker 2>/dev/null | sort -h | tail -n 40 || true
  fi
}

report_snapshot() {
  # Short, bounded snapshot suitable for embedding in prompts/logs.
  {
    df -hT /
    echo
    if has_timeout; then
      sudo_cmd timeout 20s du -xh --max-depth=1 /var/cache /var/log /var/lib/docker /var/lib/snapd 2>/dev/null | sort -h | tail -n 30 || true
    else
      sudo_cmd du -xh --max-depth=1 /var/cache /var/log /var/lib/docker /var/lib/snapd 2>/dev/null | sort -h | tail -n 30 || true
    fi
  } 2>/dev/null
}

vacuum_journal() {
  local target="$1"
  command -v journalctl >/dev/null 2>&1 || return 0
  sudo_cmd journalctl --vacuum-size="$target" || true
}

cleanup_pacman_cache() {
  command -v paccache >/dev/null 2>&1 || return 0
  sudo_cmd paccache -rk1 || true
}

cleanup_coredumps() {
  local days="$1"
  local dir="/var/lib/systemd/coredump"
  [[ -d "$dir" ]] || return 0

  sudo_cmd find "$dir" -type f -mtime "+$days" -print -delete 2>/dev/null || true
}

snap_cleanup_disabled() {
  [[ "${SNAP_CLEANUP_ENABLED:-0}" -eq 1 ]] || return 0
  command -v snap >/dev/null 2>&1 || return 0

  # Set retention (best-effort)
  sudo_cmd snap set system "refresh.retain=${SNAP_REFRESH_RETAIN}" 2>/dev/null || true

  # Remove disabled revisions (best-effort)
  # Using $NF for notes; it contains flags like disabled/classic.
  while read -r name rev notes; do
    if [[ "$notes" == *disabled* ]]; then
      sudo_cmd snap remove "$name" --revision "$rev" || true
    fi
  done < <(snap list --all 2>/dev/null | awk 'NR>1{print $1, $3, $NF}')
}

docker_prune() {
  [[ "${DOCKER_PRUNE_ENABLED:-0}" -eq 1 ]] || return 0
  command -v docker >/dev/null 2>&1 || return 0

  # Bounded: no -a
  sudo_cmd docker system prune -f || true

  if [[ "${DOCKER_VOLUME_PRUNE_ENABLED:-0}" -eq 1 ]]; then
    sudo_cmd docker volume prune -f || true
  fi
}

notify_emergency_webhook() {
  [[ -n "${EMERGENCY_WEBHOOK_URL:-}" ]] || return 0
  command -v curl >/dev/null 2>&1 || return 0

  local usage free payload
  usage="$(root_usage_pct)"
  free="$(root_free_bytes)"

  payload=$(cat <<JSON
{"event":"disk-maintenance-emergency","root_usage_pct":${usage},"root_free_bytes":${free},"ts":"$(date -Is)"}
JSON
)

  curl -fsS -m 10 -H 'Content-Type: application/json' -d "$payload" "$EMERGENCY_WEBHOOK_URL" >/dev/null 2>&1 || true
}

agent_triage() {
  local usage free
  usage="$(root_usage_pct)"
  free="$(root_free_bytes)"

  [[ "$AGENT_CLI" != "none" ]] || return 0

  if [[ "$AGENT_CLI" == "codex" ]] && command -v codex >/dev/null 2>&1; then
    local prompt
    prompt=$(cat <<EOF
You are running in triage mode. Suggest the next SAFE disk-space recovery steps.
Constraints:
- Do NOT suggest deleting user home data.
- Do NOT suggest docker image pruning with -a.
- Prefer bounded cache/log cleanup.

Root usage: ${usage}%
Root free bytes: ${free}

Snapshot:
$(report_snapshot)
EOF
)

    if [[ "$AGENT_OUTPUT" == "json" ]]; then
      printf '%s' "$prompt" | codex exec --skip-git-repo-check --sandbox read-only --json -o --color never - 2>/dev/null || true
    else
      printf '%s' "$prompt" | codex exec --skip-git-repo-check --sandbox read-only --color never - 2>/dev/null || true
    fi
    return 0
  fi

  if [[ "$AGENT_CLI" == "opencode" ]] && command -v opencode >/dev/null 2>&1; then
    local msg
    msg="Triage mode: suggest next safe disk-space recovery steps. Root usage=${usage}%. Root free bytes=${free}."

    if [[ "$AGENT_OUTPUT" == "json" ]]; then
      opencode run --format json "$msg" 2>/dev/null || true
    else
      opencode run "$msg" 2>/dev/null || true
    fi
    return 0
  fi

  return 0
}

should_cleanup() {
  local usage
  usage="$(root_usage_pct)"
  [[ "$usage" -ge "${CLEANUP_THRESHOLD_PCT}" ]]
}

should_emergency() {
  local usage free
  usage="$(root_usage_pct)"
  free="$(root_free_bytes)"

  if [[ "$usage" -ge "${EMERGENCY_THRESHOLD_PCT}" ]]; then
    return 0
  fi
  if [[ "$free" -lt "${EMERGENCY_MIN_FREE_BYTES}" ]]; then
    return 0
  fi
  return 1
}

case "$MODE" in
  report)
    load_config
    emit_history_record
    report_top
    ;;

  cleanup)
    load_config
    emit_history_record
    if ! should_cleanup; then
      echo "[disk-maintenance] below threshold; report-only"
      report_top
      exit 0
    fi

    cleanup_pacman_cache
    vacuum_journal "$JOURNAL_VACUUM_CLEANUP"
    cleanup_coredumps "$COREDUMP_RETENTION_DAYS"
    snap_cleanup_disabled
    docker_prune

    emit_history_record
    report_top
    ;;

  emergency)
    load_config
    emit_history_record
    if ! should_emergency; then
      echo "[disk-maintenance] emergency conditions not met; report-only"
      report_top
      exit 0
    fi

    notify_emergency_webhook

    cleanup_pacman_cache
    vacuum_journal "$JOURNAL_VACUUM_EMERGENCY"
    snap_cleanup_disabled
    docker_prune

    echo
    echo "[disk-maintenance] agent triage report (best-effort)"
    agent_triage || true

    emit_history_record
    report_top
    ;;

  *)
    echo "Usage: $0 {report|cleanup|emergency}" >&2
    exit 2
    ;;
esac
